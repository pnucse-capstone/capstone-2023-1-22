ISO 5055	CWE-478	Missing Default Case in Switch Statement	O					1
ISO 5055	CWE-480	Use of Incorrect Operator	O		O	O		3
ISO 5055	CWE-484	Omitted Break Statement in Switch 	O		O			1
ISO 5055	CWE-561	Dead Code 	O					2
ISO 5055	CWE-570	Expression is Always False	O			O		2
ISO 5055	CWE-571	Expression is Always True	O			O		2
ISO 5055	CWE-783	Operator Precedence Logic Error 	O			O		3
ISO 5055	CWE-401	Improper Release of Memory Before Removing Last Reference		X	X	X		2
ISO 5055	CWE-119	Improper Restriction of Operations within the Bounds of a Memory Buffer			O	O		3
ISO 5055	CWE-120	Buffer Copy without Checking Size of Input			X	X		3
ISO 5055	CWE-123	Write-what-where Condition			O	O		3
ISO 5055	CWE-125	Out-of-bounds Read			O	O		3
ISO 5055	CWE-130	Improper Handling of Length Parameter Inconsistency			O	O		2
ISO 5055	CWE-131	Incorrect Calculation of Buffer Size			O	O		3
ISO 5055	CWE-170	Improper Null Termination 			X			2
ISO 5055	CWE-194	Unexpected Sign Extension 			O	O		2
ISO 5055	CWE-195	Signed to Unsigned Conversion Error			O	O		2
ISO 5055	CWE-196	Unsigned to Signed Conversion Error			O	O		2
ISO 5055	CWE-197	Numeric Truncation Error			O	O		3
ISO 5055	CWE-252	Unchecked Return Value 			O	O		3
ISO 5055	CWE-366	Race Condition within a Thread 			O	O		3
ISO 5055	CWE-369	Divide by Zero 			O	O		3
ISO 5055	CWE-415	Double Free			O	O		3
ISO 5055	CWE-416	Use After Free			O	O		3
ISO 5055	CWE-476	NULL Pointer Dereference			O			3
ISO 5055	CWE-562	Return of Stack Variable Address			O			3
ISO 5055	CWE-704	Incorrect Type Conversion or Cast			O			3
ISO 5055	CWE-787	Out-of-bounds Write			O	O		3
ISO 5055	CWE-805	Buffer Access with Incorrect Length Value			O	O		1
ISO 5055	CWE-824	Access of Uninitialized Pointer			O	O		3
ISO 5055	CWE-825	Expired Pointer Dereference			O	O		3
ISO 5055	CWE-457	Use of Uninitialized Variable			O	O		3
ISO 5055	CWE-129	Improper Validation of Array Index				O		2
ISO 5055	CWE-134	Use of Externally-Controlled Format String				X		1
ISO 5055	CWE-477	Use of Obsolete Function				O		1
ISO 5055	CWE-789	Uncontrolled Memory Allocation 				O		2
ISO 5055	CWE-798	Use of Hard-coded Credentials				O		2
SEI CERT C	PRE00-C	Prefer inline or static functions to function-like macros				O		1
SEI CERT C	PRE01-C	Use parentheses within macros around parameter names				O		3
SEI CERT C	PRE06-C	Enclose header files in an include guard				O		1
SEI CERT C	PRE07-C	Avoid using repeated question marks				O		1
SEI CERT C	PRE09-C	Do not replace secure functions with deprecated or obsolescent functions				O		3
SEI CERT C	PRE10-C	Wrap multistatement macros in a do-while loop				O		3
SEI CERT C	PRE11-C	Do not conclude macro definitions with a semicolon				O		3
SEI CERT C	PRE30-C	Do not create a universal character name through concatenation			O	O		1
SEI CERT C	PRE31-C	Avoid side effects in arguments to unsafe macros				O		1
SEI CERT C	PRE32-C	Do not use preprocessor directives in invocations of function-like macros			O	O		1
SEI CERT C	DCL00-C	Const-qualify immutable objects				O		1
SEI CERT C	DCL01-C	Do not reuse variable names in subscopes				O		1
SEI CERT C	DCL02-C	Use visually distinct identifiers				O		1
SEI CERT C	DCL06-C	Use meaningful symbolic constants to represent literal values				O		1
SEI CERT C	DCL07-C	Include the appropriate type information in function declarators				O		1
SEI CERT C	DCL10-C	Maintain the contract between the writer and caller of variadic functions				O		2
SEI CERT C	DCL11-C	Understand the type issues associated with variadic functions				O		2
SEI CERT C	DCL12-C	Implement abstract data types using opaque types				O		1
SEI CERT C	DCL13-C	Declare function parameters that are pointers to values not changed by the function as const				O		1
SEI CERT C	DCL15-C	Declare file-scope objects or functions that do not need external linkage as static				O		1
SEI CERT C	DCL16-C	Use "L," not "l," to indicate a long value				O		1
SEI CERT C	DCL18-C	Do not begin integer constants with 0 when specifying a decimal value				O		1
SEI CERT C	DCL19-C	Minimize the scope of variables and functions				O		1
SEI CERT C	DCL22-C	Use volatile for data that cannot be cached				O		1
SEI CERT C	DCL23-C	Guarantee that mutually visible identifiers are unique			O	O		2
SEI CERT C	DCL30-C	Declare objects with appropriate storage durations			O	O		2
SEI CERT C	DCL31-C	Declare identifiers before using them			O	O		1
SEI CERT C	DCL36-C	Do not declare an identifier with conflicting linkage classifications			O	O		2
SEI CERT C	DCL37-C	Do not declare or define a reserved identifier			O	O	O	1
SEI CERT C	DCL38-C	Use the correct syntax when declaring a flexible array member				O		1
SEI CERT C	DCL39-C	Avoid information leakage in structure padding				O		1
SEI CERT C	DCL40-C	Do not create incompatible declarations of the same function or object			O	O		1
SEI CERT C	DCL41-C	Do not declare variables inside a switch statement before the first case label				O		1
SEI CERT C	EXP00-C	Use parentheses for precedence of operation	O		O	O		1
SEI CERT C	EXP05-C	Do not cast away a const qualification			O	O		2
SEI CERT C	EXP08-C	Ensure pointer arithmetic is used correctly				O		2
SEI CERT C	EXP09-C	Use sizeof to determine the size of a type or variable				O		2
SEI CERT C	EXP10-C	Do not depend on the order of evaluation of subexpressions or the order in which side effects take place				O		2
SEI CERT C	EXP12-C	Do not ignore values returned by functions				O		1
SEI CERT C	EXP13-C	Treat relational and equality operators as if they were nonassociative				O		1
SEI CERT C	EXP15-C	Do not place a semicolon on the same line as an if, for, or while statement				O		3
SEI CERT C	EXP19-C	Use braces for the body of an if, for, or while statement				O		2
SEI CERT C	EXP30-C	Do not depend on the order of evaluation for side effects			O	O	O	2
SEI CERT C	EXP32-C	Do not access a volatile object through a nonvolatile reference			O	O		2
SEI CERT C	EXP33-C	Do not read uninitialized memory			O	O		3
SEI CERT C	EXP34-C	Do not dereference null pointers			O	O		3
SEI CERT C	EXP35-C	Do not modify objects with temporary lifetime				O		1
SEI CERT C	EXP36-C	Do not cast pointers into more strictly aligned pointer types			O	O		1
SEI CERT C	EXP37-C	Call functions with the correct number and type of arguments			O	O		1
SEI CERT C	EXP39-C	Do not access a variable through a pointer of an incompatible type			O	O	O	1
SEI CERT C	EXP40-C	Do not modify constant objects			O	O		1
SEI CERT C	EXP42-C	Do not compare padding data				O		2
SEI CERT C	EXP43-C	Avoid undefined behavior when using restrict-qualified pointers			O	O		1
SEI CERT C	EXP44-C	Do not rely on side effects in operands to sizeof, _Alignof, or _Generic				O	O	1
SEI CERT C	EXP45-C	Do not perform assignments in selection statements	O		O	O		2
SEI CERT C	EXP46-C	Do not use a bitwise operator with a Boolean-like operand	O		O	O		2
SEI CERT C	EXP47-C	Do not call va_arg with an argument of the incorrect type				O		2
SEI CERT C	INT00-C	Understand the data model used by your implementation(s)				O		1
SEI CERT C	INT02-C	Understand integer conversion rules				O		2
SEI CERT C	INT04-C	Enforce limits on integer values originating from tainted sources				O		2
SEI CERT C	INT07-C	Use only explicitly signed or unsigned char type for numeric values				O		2
SEI CERT C	INT08-C	Verify that all integer values are in range				O		1
SEI CERT C	INT09-C	Ensure enumeration constants map to unique values				O		1
SEI CERT C	INT10-C	Do not assume a positive remainder when using the % operator				O		1
SEI CERT C	INT12-C	Do not make assumptions about the type of a plain int bit-field when used in an expression				O		1
SEI CERT C	INT13-C	Use bitwise operators only on unsigned operands				O		2
SEI CERT C	INT14-C	Avoid performing bitwise and arithmetic operations on the same data				O		1
SEI CERT C	INT18-C	Evaluate integer expressions in a larger size before comparing or assigning to that size				O		3
SEI CERT C	INT30-C	Ensure that unsigned integer operations do not wrap				O		2
SEI CERT C	INT31-C	Ensure that integer conversions do not result in lost or misinterpreted data				O		2
SEI CERT C	INT32-C	Ensure that operations on signed integers do not result in overflow			O	O		2
SEI CERT C	INT33-C	Ensure that division and remainder operations do not result in divide-by-zero errors			O	O		2
SEI CERT C	INT34-C	Do not shift an expression by a negative number of bits or by greater than or equal to the number of bits that exist in the operand			O	O		1
SEI CERT C	INT35-C	Use correct integer precisions				O		1
SEI CERT C	INT36-C	Converting a pointer to integer or integer to pointer			O	O		1
SEI CERT C	FLP00-C	Understand the limitations of floating-point numbers				O		1
SEI CERT C	FLP02-C	Avoid using floating-point numbers when precise computation is needed				O		1
SEI CERT C	FLP03-C	Detect and handle floating-point errors				O		1
SEI CERT C	FLP06-C	Convert integers to floating point for floating-point operations				O		2
SEI CERT C	FLP30-C	Do not use floating-point variables as loop counters				O		2
SEI CERT C	FLP32-C	Prevent or detect domain and range errors in math functions				O		2
SEI CERT C	FLP34-C	Ensure that floating-point conversions are within range of the new type			O	O		1
SEI CERT C	FLP36-C	Preserve precision when converting integral values to floating-point type				O		1
SEI CERT C	FLP37-C	Do not use object representations to compare floating-point values				O		1
SEI CERT C	ARR01-C	Do not apply the sizeof operator to a pointer when taking the size of an array				O		3
SEI CERT C	ARR02-C	Explicitly specify array bounds, even if implicitly defined by an initializer				O		2
SEI CERT C	ARR30-C	Do not form or use out-of-bounds pointers or array subscripts			O	O		2
SEI CERT C	ARR32-C	Ensure size arguments for variable length arrays are in a valid range			O	O		2
SEI CERT C	ARR36-C	Do not subtract or compare two pointers that do not refer to the same array			O	O		2
SEI CERT C	ARR37-C	Do not add or subtract an integer to a pointer to a non-array object				O		2
SEI CERT C	ARR38-C	Guarantee that library functions do not form invalid pointers			O	O		3
SEI CERT C	ARR39-C	Do not add or subtract a scaled integer to a pointer				O		2
SEI CERT C	STR02-C	Sanitize data passed to complex subsystems				O		3
SEI CERT C	STR03-C	Do not inadvertently truncate a string				O		2
SEI CERT C	STR07-C	Use the bounds-checking interfaces for string manipulation				O		3
SEI CERT C	STR11-C	Do not specify the bound of a character array initialized with a string literal				O		2
SEI CERT C	STR30-C	Do not attempt to modify string literals			O	O		2
SEI CERT C	STR31-C	Guarantee that storage for strings has sufficient space for character data and the null terminator			O	O		3
SEI CERT C	STR32-C	Do not pass a non-null-terminated character sequence to a library function that expects a string			O	O		3
SEI CERT C	STR34-C	Cast characters to unsigned char before converting to larger integer sizes				O		2
SEI CERT C	STR37-C	Arguments to character-handling functions must be representable as an unsigned char			O	O		1
SEI CERT C	STR38-C	Do not confuse narrow and wide character strings and functions				O		3
SEI CERT C	MEM00-C	Allocate and free memory in the same module, at the same level of abstraction				O		3
SEI CERT C	MEM01-C	Store a new value in pointers immediately after free()				O		2
SEI CERT C	MEM02-C	Immediately cast the result of a memory allocation function call into a pointer to the allocated type				O		1
SEI CERT C	MEM03-C	Clear sensitive information stored in reusable resources				O		1
SEI CERT C	MEM04-C	Beware of zero-length allocations			O	O	O	2
SEI CERT C	MEM05-C	Avoid large stack allocations				O		2
SEI CERT C	MEM06-C	Ensure that sensitive data is not written out to disk				O		1
SEI CERT C	MEM11-C	Do not assume infinite heap space				O		1
SEI CERT C	MEM12-C	Consider using a goto chain when leaving a function on error when using and releasing resources				O		1
SEI CERT C	MEM30-C	Do not access freed memory			O	O		3
SEI CERT C	MEM31-C	Free dynamically allocated memory when no longer needed		O	O	O		2
SEI CERT C	MEM33-C	Allocate and copy structures containing a flexible array member dynamically				O		1
SEI CERT C	MEM34-C	Only free memory allocated dynamically			O	O		3
SEI CERT C	MEM35-C	Allocate sufficient memory for an object				O		2
SEI CERT C	MEM36-C	Do not modify the alignment of objects by calling realloc()				O		1
SEI CERT C	FIO02-C	Canonicalize path names originating from tainted sources				O		2
SEI CERT C	FIO11-C	Take care when specifying the mode parameter of fopen()				O		2
SEI CERT C	FIO21-C	Do not create temporary files in shared directories				O		2
SEI CERT C	FIO24-C	Do not open a file that is already open				O		1
SEI CERT C	FIO30-C	Exclude user input from format strings				O		3
SEI CERT C	FIO32-C	Do not perform operations on devices that are only appropriate for files				O		1
SEI CERT C	FIO34-C	Distinguish between characters read from a file and EOF or WEOF				O		3
SEI CERT C	FIO37-C	Do not assume that fgets() or fgetws() returns a nonempty string when successful				O		3
SEI CERT C	FIO38-C	Do not copy a FILE object				O		1
SEI CERT C	FIO39-C	Do not alternately input and output from a stream without an intervening flush or positioning call			O	O		2
SEI CERT C	FIO40-C	Reset strings on fgets() or fgetws() failure			O	O		1
SEI CERT C	FIO41-C	Do not call getc(), putc(), getwc(), or putwc() with a stream argument that has side effects				O		1
SEI CERT C	FIO42-C	Close files when they are no longer needed		O	O	O		1
SEI CERT C	FIO44-C	Only use values for fsetpos() that are returned from fgetpos()				O		1
SEI CERT C	FIO45-C	Avoid TOCTOU race conditions while accessing files				O		2
SEI CERT C	FIO46-C	Do not access a closed file			O	O		1
SEI CERT C	FIO47-C	Use valid format strings			O	O		2
SEI CERT C	ENV01-C	Do not make assumptions about the size of an environment variable			O	O		3
SEI CERT C	ENV30-C	Do not modify the object referenced by the return value of certain functions			O	O		1
SEI CERT C	ENV31-C	Do not rely on an environment pointer following an operation that may invalidate it				O		1
SEI CERT C	ENV32-C	All exit handlers must return normally			O	O		3
SEI CERT C	ENV33-C	Do not call system()				O		3
SEI CERT C	ENV34-C	Do not store pointers returned by certain functions				O		1
SEI CERT C	SIG30-C	Call only asynchronous-safe functions within signal handlers			O	O		3
SEI CERT C	SIG31-C	Do not access shared objects in signal handlers			O	O		2
SEI CERT C	SIG34-C	Do not call signal() from within interruptible signal handlers				O		1
SEI CERT C	SIG35-C	Do not return from a computational exception signal handler			O	O		1
SEI CERT C	ERR00-C	Adopt and implement a consistent and comprehensive error-handling policy				O		1
SEI CERT C	ERR30-C	Take care when reading errno				O		2
SEI CERT C	ERR32-C	Do not rely on indeterminate values of errno			O	O		1
SEI CERT C	ERR33-C	Detect and handle standard library errors				O		3
SEI CERT C	ERR34-C	Detect errors when converting a string to a number				O		1
SEI CERT C	API04-C	Provide a consistent and usable error-checking mechanism				O		1
SEI CERT C	CON01-C	Acquire and release synchronization primitives in the same module, at the same level of abstraction				O		1
SEI CERT C	CON05-C	Do not perform operations that can block while holding a lock				O		1
SEI CERT C	CON30-C	Clean up thread-specific storage				O		1
SEI CERT C	CON31-C	Do not destroy a mutex while it is locked				O		1
SEI CERT C	CON32-C	Prevent data races when accessing bit-fields from multiple threads				O		2
SEI CERT C	CON33-C	Avoid race conditions when using library functions				O		1
SEI CERT C	CON34-C	Declare objects shared between threads with appropriate storage durations				O		1
SEI CERT C	CON35-C	Avoid deadlock by locking in a predefined order				O		1
SEI CERT C	CON36-C	Wrap functions that can spuriously wake up in a loop				O		1
SEI CERT C	CON37-C	Do not call signal() in a multithreaded program			O	O		2
SEI CERT C	CON38-C	Preserve thread safety and liveness when using condition variables				O		1
SEI CERT C	CON39-C	Do not join or detach a thread that was previously joined or detached				O		2
SEI CERT C	CON40-C	Do not refer to an atomic variable twice in an expression				O		2
SEI CERT C	CON41-C	Wrap functions that can fail spuriously in a loop				O		1
SEI CERT C	CON43-C	Do not allow data races in multithreaded code				O		1
SEI CERT C	MSC01-C	Strive for logical completeness				O		2
SEI CERT C	MSC04-C	Use comments consistently and in a readable fashion				O		1
SEI CERT C	MSC12-C	Detect and remove code that has no effect or is never executed				O		1
SEI CERT C	MSC13-C	Detect and remove unused values				O		1
SEI CERT C	MSC15-C	Do not depend on undefined behavior			O	O	O	3
SEI CERT C	MSC17-C	Finish every set of statements associated with a case label with a break statement				O		3
SEI CERT C	MSC18-C	Be careful while handling sensitive data, such as passwords, in program code				O		2
SEI CERT C	MSC20-C	Do not use a switch statement to transfer control into a complex block				O		2
SEI CERT C	MSC21-C	Use robust loop termination conditions				O		1
SEI CERT C	MSC22-C	Use the setjmp(), longjmp() facility securely			O	O		1
SEI CERT C	MSC24-C	Do not use deprecated or obsolescent functions				O		3
SEI CERT C	MSC30-C	Do not use the rand() function for generating pseudorandom numbers				O		2
SEI CERT C	MSC32-C	Properly seed pseudorandom number generators				O		3
SEI CERT C	MSC33-C	Do not pass invalid data to the asctime() function				O		3
SEI CERT C	MSC37-C	Ensure that control never reaches the end of a non-void function			O	O		2
SEI CERT C	MSC38-C	Do not treat a predefined identifier as an object if it might only be implemented as a macro			O	O		1
SEI CERT C	MSC39-C	Do not call va_arg() on a va_list that has an indeterminate value				O		1
SEI CERT C	MSC40-C	Do not violate constraints				O		1
SEI CERT C	MSC41-C	Never hard code sensitive information				O		3
SEI CERT C	POS05-C	Limit access to files by creating a jail				O		1
SEI CERT C	POS30-C	Use the readlink() function properly				O		3
SEI CERT C	POS34-C	Do not call putenv() with a pointer to an automatic variable as the argument				O		2
SEI CERT C	POS35-C	Avoid race conditions while checking for the existence of a symbolic link				O		3
SEI CERT C	POS36-C	Observe correct revocation order while relinquishing privileges				O		3
SEI CERT C	POS37-C	Ensure that privilege relinquishment is successful				O		3
SEI CERT C	POS38-C	Beware of race conditions when using fork and file descriptors				O		1
SEI CERT C	POS39-C	Use the correct byte ordering when transferring data between systems				O		3
SEI CERT C	POS44-C	Do not use signals to terminate threads				O		2
SEI CERT C	POS47-C	Do not use threads that can be canceled asynchronously				O		3
SEI CERT C	POS48-C	Do not unlock or destroy another POSIX thread's mutex				O		1
SEI CERT C	POS49-C	When data must be accessed by multiple threads, provide a mutex and guarantee no adjacent data is also accessed				O		2
SEI CERT C	POS50-C	Declare objects shared between POSIX threads with appropriate storage durations				O		1
SEI CERT C	POS51-C	Avoid deadlock with POSIX threads by locking in predefined order				O		1
SEI CERT C	POS52-C	Do not perform operations that can block while holding a POSIX lock				O		1
SEI CERT C	POS53-C	Do not use more than one mutex for concurrent waiting operations on a condition variable				O		1
SEI CERT C	POS54-C	Detect and handle POSIX library errors				O		3
SEI CERT C	WIN00-C	Be specific when dynamically loading libraries				O		2
SEI CERT C	WIN30-C	Properly pair allocation and deallocation functions				O		2
MISRA C:2012	Rule 1.1	The program shall contain no violations of the standard C syntax and constraints, and shall not exceed the implementation’s translation limits	 	 	O	 	 	2
MISRA C:2012	Rule 1.2	Language extensions should not be used	 	 	O		 	1
MISRA C:2012	Rule 1.3	There shall be no occurrence of undefined or critical unspecified behaviour	 	 	O		 	2
MISRA C:2012	Rule 1.4	Emergent language features shall not be used	 	 	O		 	2
MISRA C:2012	Rule 2.1	A project shall not contain unreachable code	 	 	O		 	2
MISRA C:2012	Rule 2.2	There shall be no dead code	 	 	O		 	2
MISRA C:2012	Rule 2.3	A project should not contain unused type declarations	 	 	O		 	1
MISRA C:2012	Rule 2.4	A project should not contain unused tag declarations	 	 	O		 	1
MISRA C:2012	Rule 2.5	A project should not contain unused macro declarations	 	 	O		 	1
MISRA C:2012	Rule 2.6	A function should not contain unused label declarations	 	 	O		 	1
MISRA C:2012	Rule 2.7	There should be no unused parameters in functions	 	 	O		 	1
MISRA C:2012	Rule 3.1	The character sequences /* and // shall not be used within a comment	 	 	O		 	2
MISRA C:2012	Rule 3.2	Line-splicing shall not be used in // comments	 	 	O		 	2
MISRA C:2012	Rule 4.1	Octal and hexadecimal escape sequences shall be terminated	 	 	 		O	2
MISRA C:2012	Rule 4.2	Trigraphs should not be used Identifiers	 	 	O		 	1
MISRA C:2012	Rule 5.1	External identifi ers shall be distinct	 	 	O		O	2
MISRA C:2012	Rule 5.2	Identifiers declared in the same scope and name space shall be distinct	 	 	O		 	2
MISRA C:2012	Rule 5.3	An identifier declared in an inner scope shall not hide an identifier declared in an outer scope	 	 	O		 	2
MISRA C:2012	Rule 5.4	Macro identifiers shall be distinct	 	 	O		O	2
MISRA C:2012	Rule 5.5	Identifi ers shall be distinct from macro names	 	 	O		O	2
MISRA C:2012	Rule 5.6	A typedef name shall be a unique identifi er	 	 	O		 	2
MISRA C:2012	Rule 5.7	A tag name shall be a unique identifi er	 	 	O		 	2
MISRA C:2012	Rule 5.8	Identifi ers that defi ne objects or functions with external linkage shall be unique	 	 	O		 	2
MISRA C:2012	Rule 5.9	Identifi ers that defi ne objects or functions with internal linkage should be unique	 	 	O		 	1
MISRA C:2012	Rule 6.1	Bit-fields shall only be declared with an appropriate type	 	 	O		O	2
MISRA C:2012	Rule 6.2	Single-bit named bit fi elds shall not be of a signed type	 	 	O		 	2
MISRA C:2012	Rule 7.1	Octal constants shall not be used	 	 	O		 	2
MISRA C:2012	Rule 7.2	A “u” or “U” suffi x shall be applied to all integer constants that are represented in an unsigned type	 	 	O		 	2
MISRA C:2012	Rule 7.3	The lowercase character “l” shall not be used in a literal suffi x	 	 	O		 	2
MISRA C:2012	Rule 7.4	A string literal shall not be assigned to an object unless the object’s type is “pointer to const-qualifi ed char”Declarations and defi nitions	 	 	O		O	2
MISRA C:2012	Rule 8.1	Types shall be explicitly specifi ed	 	 	O		 	2
MISRA C:2012	Rule 8.2	Function types shall be in prototype form with named parameters	 	 	O		 	2
MISRA C:2012	Rule 8.3	All declarations of an object or function shall use the same names and type qualifiers	 	 	O		 	2
MISRA C:2012	Rule 8.4	A compatible declaration shall be visible when an object or function with external linkage is defi ned	 	 	O		 	2
MISRA C:2012	Rule 8.5	An external object or function shall be declared once in one and only one file	 	 	O		 	2
MISRA C:2012	Rule 8.6	An identifi er with external linkage shall have exactly one external definition	 	 	O		 	2
MISRA C:2012	Rule 8.7	Functions and objects should not be defi ned with external linkage if they are referenced in only one translation unit	 	 	O		 	1
MISRA C:2012	Rule 8.8	The static storage class specifi er shall be used in all declarations of objects and functions that have internal linkage	 	 	O		 	2
MISRA C:2012	Rule 8.9	An object should be defi ned at block scope if its identifi er only appears in a single function	 	 	O		 	1
MISRA C:2012	Rule 8.10	An inline function shall be declared with the static storage class	 	 	O		O	2
MISRA C:2012	Rule 8.11	When an array with external linkage is declared, its size should be explicitly specified	 	 	O		 	1
MISRA C:2012	Rule 8.12	Within an enumerator list, the value of an implicitly-specified enumeration constant shall be unique	 	 	O		 	2
MISRA C:2012	Rule 8.13	A pointer should point to a const-qualifi ed type whenever possible	 	 	O		 	1
MISRA C:2012	Rule 8.14	The restrict type qualifi er shall not be used	 	 	O		 	2
MISRA C:2012	Rule 9.1	The value of an object with automatic storage duration shall not be read before it has been set	 	 	O		 	3
MISRA C:2012	Rule 9.2	The initializer for an aggregate or union shall be enclosed in braces	 	 	O		 	2
MISRA C:2012	Rule 9.3	Arrays shall not be partially initialized	 	 	O		 	2
MISRA C:2012	Rule 9.4	An element of an object shall not be initialized more than once	 	 	O		 	2
MISRA C:2012	Rule 9.5	Where designated initializers are used to initialize an array object the size of the array shall be specified explicitly	 	 	O		 	2
MISRA C:2012	Rule 10.1	Operands shall not be of an inappropriate essential type	 	 	O		O	2
MISRA C:2012	Rule 10.2	Expressions of essentially character type shall not be used inappropriately in addition and subtraction operations	 	 	O		 	2
MISRA C:2012	Rule 10.3	The value of an expression shall not be assigned to an object with a narrower essential type or of a different essential type category	 	 	O		O	2
MISRA C:2012	Rule 10.4	Both operands of an operator in which the usual arithmetic conversions are performed shall have the same essential type category	 	 	 		O	2
MISRA C:2012	Rule 10.5	The value of an expression should not be cast to an inappropriate essential type	 	 	O		 	1
MISRA C:2012	Rule 10.6	The value of a composite expression shall not be assigned to an object with wider essential type	 	 	O		 	2
MISRA C:2012	Rule 10.7	If a composite expression is used as one operand of an operator in which the usual arithmetic conversions are performed then the other operand shall not have wider essential type	 	 	O		 	2
MISRA C:2012	Rule 10.8	The value of a composite expression shall not be cast to a different essential type category or a wider essential type	 	 	O		 	2
MISRA C:2012	Rule 11.1	Conversions shall not be performed between a pointer to a function and any other type	 	 	O		 	2
MISRA C:2012	Rule 11.2	Conversions shall not be performed between a pointer to an incomplete type and any other type	 	 	O		 	2
MISRA C:2012	Rule 11.3	A cast shall not be performed between a pointer to object type and a pointer to a diff erent object type	 	 	O		 	2
MISRA C:2012	Rule 11.4	A conversion should not be performed between a pointer to object and an integer type	 	 	O		O	1
MISRA C:2012	Rule 11.5	A conversion should not be performed from pointer to void into pointer to object 	 	 	O		 	1
MISRA C:2012	Rule 11.6	A cast shall not be performed between pointer to void and an arithmetic type	 	 	O		O	2
MISRA C:2012	Rule 11.7	A cast shall not be performed between pointer to object and a non integer arithmetic type	 	 	O		O	2
MISRA C:2012	Rule 11.8	A cast shall not remove any const or volatile qualifi cation from the type pointed to by a pointer	 	 	O		 	2
MISRA C:2012	Rule 11.9	The macro NULL shall be the only permitted form of integer null pointer constant	 	 	O		 	2
MISRA C:2012	Rule 12.1	The precedence of operators within expressions should be made explicit	 	 	O		 	1
MISRA C:2012	Rule 12.2	The right hand operand of a shift operator shall lie in the range zero to one less than the width in bits of the essential type of the left hand operand	 	 	O		 	2
MISRA C:2012	Rule 12.3	The comma operator should not be used	 	 	O		 	1
MISRA C:2012	Rule 12.4	Evaluation of constant expressions should not lead to unsigned integer wrap-around	 	 	O		 	1
MISRA C:2012	Rule 12.5	The sizeof operator shall not have an operand which is a function parameter declared as “array of type”	 	 	 		 	3
MISRA C:2012	Rule 13.1	Initializer lists shall not contain persistent side effects	 	 	 		O	2
MISRA C:2012	Rule 13.2	The value of an expression and its persistent side eff ects shall be the same under all permitted evaluation orders	 	 	O		O	2
MISRA C:2012	Rule 13.3	A full expression containing an increment (++) or decrement (--) operator should have no other potential side eff ects other than that caused by the increment or decrement operator	 	 	O		O	1
MISRA C:2012	Rule 13.4	The result of an assignment operator should not be used	 	 	O		O	1
MISRA C:2012	Rule 13.5	The right hand operand of a logical && or || operator shall not contain persistent side effects	 	 	O		 	2
MISRA C:2012	Rule 13.6	The operand of the sizeof operator shall not contain any expression which has potential side effects	 	 	 		O	3
MISRA C:2012	Rule 14.1	A loop counter shall not have essentially floating type	 	 	O		 	2
MISRA C:2012	Rule 14.2	A for loop shall be well-formed	 	 	O		 	2
MISRA C:2012	Rule 14.3	Controlling expressions shall not be invariant	 	 	O		 	2
MISRA C:2012	Rule 14.4	The controlling expression of an if statement and the controlling expression of an iteration-statement shall have essentially Boolean type	 	 	O		 	2
MISRA C:2012	Rule 15.1	The goto statement should not be used	 	 	O		 	1
MISRA C:2012	Rule 15.2	The goto statement shall jump to a label declared later in the same function	 	 	O		 	2
MISRA C:2012	Rule 15.3	Any label referenced by a goto statement shall be declared in the same block, or in any block enclosing the goto statement	 	 	O		 	2
MISRA C:2012	Rule 15.4	There should be no more than one break or goto statement used to terminate any iteration statement	 	 	O		 	1
MISRA C:2012	Rule 15.5	A function should have a single point of exit at the end	 	 	O		 	1
MISRA C:2012	Rule 15.6	The body of an iteration-statement or a selection-statement shall be a compound-statement	 	 	O		 	2
MISRA C:2012	Rule 15.7	All if … else if constructs shall be terminated with an else statement	 	 	O		 	2
MISRA C:2012	Rule 16.1	All switch statements shall be well-formed	 	 	O		 	2
MISRA C:2012	Rule 16.2	A switch label shall only be used when the most closely-enclosing compound statement is the body of a switch statement	 	 	O		 	2
MISRA C:2012	Rule 16.3	An unconditional break statement shall terminate every switch-clause	 	 	O		 	2
MISRA C:2012	Rule 16.4	Every switch statement shall have a default label	 	 	O		 	2
MISRA C:2012	Rule 16.5	A default label shall appear as either the fi rst or the last switch label of a switch statement	 	 	O		 	2
MISRA C:2012	Rule 16.6	Every switch statement shall have at least two switch-clauses	 	 	O		 	2
MISRA C:2012	Rule 16.7	A switch-expression shall not have essentially Boolean type	 	 	O		 	2
MISRA C:2012	Rule 17.1	The features of <stdarg.h> shall not be used	 	 	O		O	2
MISRA C:2012	Rule 17.2	Functions shall not call themselves, either directly or indirectly	 	 	O		 	2
MISRA C:2012	Rule 17.3	A function shall not be declared implicitly	 	 	O		 	3
MISRA C:2012	Rule 17.4	All exit paths from a function with non-void return type shall have an explicit return statement with an expression	 	 	O		 	3
MISRA C:2012	Rule 17.5	The function argument corresponding to a parameter declared to have an array type shall have an appropriate number of elements	 	 	O		 	1
MISRA C:2012	Rule 17.6	The declaration of an array parameter shall not contain the static keyword between the [ ]	 	 	O		 	3
MISRA C:2012	Rule 17.7	The value returned by a function having non-void return type shall be used	 	 	O		 	2
MISRA C:2012	Rule 17.8	A function parameter should not be modified	 	 	O		 	1
MISRA C:2012	Rule 18.1	A pointer resulting from arithmetic on a pointer operand shall address an element of the same array as that pointer operand	 	 	O		O	2
MISRA C:2012	Rule 18.2	Subtraction between pointers shall only be applied to pointers that address elements of the same array	 	 	O		O	2
MISRA C:2012	Rule 18.3	The relational operators >, >=, < and <= shall not be applied to objects of pointer type except where they point into the same object	 	 	O		O	2
MISRA C:2012	Rule 18.4	The +, -, += and -= operators should not be applied to an expression of pointer type	 	 	O		 	1
MISRA C:2012	Rule 18.5	Declarations should contain no more than two levels of pointer nesting	 	 	O		 	1
MISRA C:2012	Rule 18.6	The address of an object with automatic storage shall not be copied to another object that persists after the fi rst object has ceased to exist	 	 	O		 	2
MISRA C:2012	Rule 18.7	Flexible array members shall not be declared	 	 	O		 	2
MISRA C:2012	Rule 18.8	Variable-length array types shall not be used	 	 	O		O	2
MISRA C:2012	Rule 19.1	An object shall not be assigned or copied to an overlapping object	 	 	O		 	3
MISRA C:2012	Rule 19.2	The union keyword should not be used Preprocessing directives	 	 	O		O	1
MISRA C:2012	Rule 20.1	#include directives should only be preceded by preprocessor directives or comments	 	 	O		 	1
MISRA C:2012	Rule 20.2	The ', " or \ characters and the /* or // character sequences shall not occur in a header file name	 	 	O		 	2
MISRA C:2012	Rule 20.3	The #include directive shall be followed by either a <filename> or "filename" sequence	 	 	O		 	2
MISRA C:2012	Rule 20.4	A macro shall not be defi ned with the same name as a keyword	 	 	O		 	2
MISRA C:2012	Rule 20.5	#undef should not be used	 	 	O		 	1
MISRA C:2012	Rule 20.6	Tokens that look like a preprocessing directive shall not occur within a macro argument	 	 	O		 	2
MISRA C:2012	Rule 20.7	Expressions resulting from the expansion of macro parameters shall be enclosed in parentheses	 	 	O		 	2
MISRA C:2012	Rule 20.8	The controlling expression of a #if or #elif preprocessing directive shall evaluate to 0 or 1	 	 	O		 	2
MISRA C:2012	Rule 20.9	All identifi ers used in the controlling expression of #if or #elif preprocessing directives shall be #defi ne’d before evaluation	 	 	O		 	2
MISRA C:2012	Rule 20.10	The # and ## preprocessor operators should not be used	 	 	O		O	1
MISRA C:2012	Rule 20.11	A macro parameter immediately following a # operator shall not immediately be followed by a ## operator	 	 	 		O	2
MISRA C:2012	Rule 20.12	A macro parameter used as an operand to the # or ## operators, which is itself subject to further macro replacement, shall only be used as an operand to these operators	 	 	O		 	2
MISRA C:2012	Rule 20.13	A line whose fi rst token is # shall be a valid preprocessing directive	 	 	O		 	2
MISRA C:2012	Rule 20.14	All #else, #elif and #endif preprocessor directives shall reside in the same fi le as the #if, #ifdef or #ifndef directive to which they are related	 	 	O		 	2
MISRA C:2012	Rule 21.1	#defi ne and #undef shall not be used on a reserved identifier or reserved macro name	 	 	O		 	2
MISRA C:2012	Rule 21.2	A reserved identifi er or macro name shall not be declared	 	 	O		 	2
MISRA C:2012	Rule 21.3	The memory allocation and deallocation functions of <stdlib.h> shall not be used	 	 	O		O	2
MISRA C:2012	Rule 21.4	The standard header file <setjmp.h> shall not be used	 	 	O		O	2
MISRA C:2012	Rule 21.5	The standard header file <signal.h> shall not be used	 	 	O		O	2
MISRA C:2012	Rule 21.6	The Standard Library input/output functions shall not be used	 	 	O		O	2
MISRA C:2012	Rule 21.7	The atof, atoi, atol and atoll functions of <stdlib.h> shall not be used	 	 	O		 	2
MISRA C:2012	Rule 21.8	The Standard Library termination functions of <stdlib.h> shall not be used	 	 	O		O	2
MISRA C:2012	Rule 21.9	The library functions bsearch and qsort of <stdlib.h> shall not be used	 	 	O		O	2
MISRA C:2012	Rule 21.10	The Standard Library time and date functions shall not be used	 	 	O		O	2
MISRA C:2012	Rule 21.11	The standard header fi le <tgmath.h> shall not be used	 	 	O		 	2
MISRA C:2012	Rule 21.12	The exception handling features of <fenv.h> should not be used	 	 	O		O	1
MISRA C:2012	Rule 21.13	Any value passed to a function in <ctype.h> shall be representable as an unsigned char or be the value EOF	 	 	O		 	3
MISRA C:2012	Rule 21.14	The Standard Library function memcmp shall not be used to compare null terminated strings	 	 	O		 	2
MISRA C:2012	Rule 21.15	The pointer arguments to the Standard Library functions memcpy, memmove and memcmp shall be pointers to qualified or unqualified versions of compatible types	 	 	O		 	2
MISRA C:2012	Rule 21.16	The pointer arguments to the Standard Library function memcmp shall point to either a pointer type, an essentially signed type, an essentially unsigned type, an essentially Boolean type or an essentially enum type	 	 	 		O	2
MISRA C:2012	Rule 21.17	Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters	 	 	O		 	3
MISRA C:2012	Rule 21.18	The size_t argument passed to any function in <string.h> shall have an appropriate value 	 	 	O		 	3
MISRA C:2012	Rule 21.19	The pointers returned by the Standard Library functions localeconv, getenv, setlocale or, strerror shall only be used as if they have pointer to const-qualified type	 	 	O		 	3
MISRA C:2012	Rule 21.20	The pointer returned by the Standard Library functions asctime, ctime, gmtime, localtime, localeconv, getenv, setlocale or strerror shall not be used following a subsequent call to the same function	 	 	O		 	3
MISRA C:2012	Rule 21.21	The Standard Library function system of <stdlib.h> shall not be used	 	 	O		O	2
MISRA C:2012	Rule 22.1	All resources obtained dynamically by means of Standard Library functions shall be explicitly released	 	 	O		 	2
MISRA C:2012	Rule 22.2	A block of memory shall only be freed if it was allocated by means of a Standard Library function	 	 	O		 	3
MISRA C:2012	Rule 22.3	The same fi le shall not be open for read and write access at the same time on diff erent streams	 	 	 		O	2
MISRA C:2012	Rule 22.4	There shall be no attempt to write to a stream which has been opened as read-only	 	 	O		 	3
MISRA C:2012	Rule 22.5	A pointer to a FILE object shall not be dereferenced	 	 	O		 	3
MISRA C:2012	Rule 22.6	The value of a pointer to a FILE shall not be used after the associated stream has been close	 	 	O		 	3
MISRA C:2012	Rule 22.7	The macro EOF shall only be compared with the unmodified return value from any Standard Library function capable of returning EOF	 	 	O		 	2
MISRA C:2012	Rule 22.8	The value of errno shall be set to zero prior to a call to an errno-settingfunction 	 	 	O		 	2
MISRA C:2012	Rule 22.9	The value of errno shall be tested against zero after calling an errnosetting-function 19	 	 	O		 	2
MISRA C:2012	Rule 22.10	The value of errno shall only be tested when the last function to be called was an errno-setting-function	 	 	O		 	2
MISRA C:2012	Dir 1.1	2 Any implementation-defi ned behavio ur on which the output of the program depends shall be documented and understood	 		O		 	2
MISRA C:2012	Dir 2.1	2 All source fi les shall compile without any compilation errors	 		O		 	2
MISRA C:2012	Dir 4.1	2 Run-time failures shall be minimized	 		O		 	2
MISRA C:2012	Dir 4.3	2 Assembl y language shall be encapsulated and isolated	 		O		 	2
MISRA C:2012	Dir 4.4	1 Sections of code should not be “commented out”	 		O		 	1
MISRA C:2012	Dir 4.5	1 Identifi ers in the same name space with overlapping visibility should be typographically unambiguous	 		O		 	1
MISRA C:2012	Dir 4.6	1 typedefs that indicate size and signedness should be used in place of the basic numerical types	 		O		 	1
MISRA C:2012	Dir 4.7	2 If a function returns error information, then that error information shall be tested	 		O		 	2
MISRA C:2012	Dir 4.8	1 If a pointer to a structure or union is never dereferenced within a translation unit, then the implementation of the object should be hidden	 		O		 	1
MISRA C:2012	Dir 4.9	1 A function should be used in preference to a function-like macro where they are interchangeable	 		O		 	1
MISRA C:2012	Dir 4.10	2 Precautions shall be taken in order to prevent the contents of a header file being included more than once	 		O		 	2
MISRA C:2012	Dir 4.11	2 The validity of values passed to library functions shall be checked	 		O		O	2
MISRA C:2012	Dir 4.12	2 Dynamic memory allocation shall not be used	 		O		 	2
MISRA C:2012	Dir 4.13	1 Functions which are designed to provide operations on a resource should be called in an appropriate sequence	 		O		 	1
MISRA C:2012	Dir 4.14	The validity of values received from external sources shall be checked	 		O		 	2